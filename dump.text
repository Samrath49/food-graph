import React, { useState, useCallback, SetStateAction, Dispatch } from "react";
import ReactFlow, {
  addEdge,
  Background,
  useNodesState,
  useEdgesState,
  Node,
  Edge,
  Connection,
} from "reactflow";
import "reactflow/dist/style.css";
import { Category, Ingredients, Meal, MealDetails, Meals } from "./types";

import useMealApi from "./hooks/useMealApi";
import { EntityNode, TagsNode, OptionNode, StartNode } from "./components";
import MealSheet from "./components/MealSheet";

const nodeTypes = {
  startNode: StartNode,
  entityNode: EntityNode,
  optionNode: OptionNode,
  tagsNode: TagsNode,
};

const initialNodes: Node[] = [
  {
    id: "1",
    type: "startNode",
    data: { label: "Explore", type: "start" },
    position: { x: 50, y: 5 },
  },
];

export default function App() {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [open, setOpen] = useState(false);
  const [selectedMeal, setSelectedMeal] = useState<Meal | undefined | null>(
    null
  );
  const { fetchData } = useMealApi<{
    meals: Category[] | Meal[] | Meals[] | Ingredients[];
  }>();

  const onConnect = useCallback(
    (connection: Connection) => {
      const edge = {
        ...connection,
        animated: true,
        id: `${edges.length} + 1`,
        type: "customEdge",
      };
      setEdges((prevEdges) => addEdge(edge, prevEdges));
    },
    [edges]
  );

  const createCategoryNodes = (categories: Category[], node: Node) => {
    return categories.map((category, index) => ({
      id: `category-${index}`,
      type: "entityNode",
      data: {
        label: category?.strCategory,
        type: "category",
        entityId: category?.strCategory,
      },
      position: { x: 350, y: node.position.y - 200 + index * 100 },
    }));
  };

  const createMealNodes = (meals: Meal[], node: Node): Node[] => {
    return meals.map((meal, index) => ({
      id: `meal-${meal.idMeal}-${Date.now()}-${Math.random()}`,
      type: "entityNode",
      data: { label: meal.strMeal, type: "meal", entityId: meal.idMeal },
      position: {
        x: node.position.x + 350,
        y: node.position.y - 200 + index * 100,
      },
    }));
  };

  const createOptionNodes = (
    node: Node,
    options: { label: string; type: string }[]
  ) => {
    return options.map((option, index) => ({
      id: `option-${option.type}-${node.id}`,
      type: "optionNode",
      data: {
        label: option.label,
        type: option.type,
        entityId: node.data.entityId,
      },
      position: {
        x: node.position.x + 350,
        y: node.position.y - 100 + index * 100,
      },
    }));
  };

  const createEdges = (sourceId: string, targetNodes: Node[]) => {
    return targetNodes.map((target) => ({
      id: `e-${sourceId}-${target.id}`,
      source: sourceId,
      target: target.id,
    }));
  };

  // Fetch categories and create category nodes
  const handleStartNode = async (
    node: Node,
    setNodes: React.Dispatch<React.SetStateAction<Node[]>>,
    setEdges: React.Dispatch<React.SetStateAction<Edge[]>>,
    fetchData: (
      endpointKey: string,
      params?: string
    ) => Promise<{
      meals: Category[] | Meal[] | Meals[] | Ingredients[];
    } | null>
  ): Promise<void> => {
    const response = await fetchData("categories");
    const categories = response?.meals?.slice(0, 5) || [];
    const newNodes = createCategoryNodes(categories as Category[], node);

    setNodes((nds) => [...nds, ...newNodes]);
    setEdges((eds) => [...eds, ...createEdges("1", newNodes)]);
  };

  // Fetch meals and create meal nodes
  const handleViewMealsNode = async (
    node: Node,
    setNodes: React.Dispatch<React.SetStateAction<Node[]>>,
    setEdges: React.Dispatch<React.SetStateAction<Edge[]>>,
    fetchData: (
      endpointKey: string,
      params?: string
    ) => Promise<{
      meals: Category[] | Meal[] | Meals[] | Ingredients[];
    } | null>,
    mealId?: string
  ) => {
    const response = await fetchData(
      "filter",
      mealId ? mealId : node.data.entityId
    );
    const meals = response?.meals?.slice(0, 5) || [];
    const newNodes = createMealNodes(meals as Meal[], node);

    setNodes((nds) => [...nds, ...newNodes]);
    setEdges((eds) => [...eds, ...createEdges(node.id, newNodes)]);
  };

  // Handle "View Ingredients", "View Tags", "View Details" for a meal node
  const handleMealOptionsNode = (
    node: Node,
    setNodes: React.Dispatch<React.SetStateAction<Node[]>>,
    setEdges: React.Dispatch<React.SetStateAction<Edge[]>>
  ) => {
    const options = [
      { label: "View Ingredients", type: "viewIngredients" },
      { label: "View Tags", type: "viewTags" },
      { label: "View Details", type: "viewDetails" },
    ];

    const optionNodes = createOptionNodes(node, options);

    setNodes((nds) => [...nds, ...optionNodes]);
    setEdges((eds) => [...eds, ...createEdges(node.id, optionNodes)]);
  };

  // Fetch ingredients and create ingredient nodes
  const handleViewIngredientsNode = async (
    node: Node,
    setNodes: React.Dispatch<React.SetStateAction<Node[]>>,
    setEdges: React.Dispatch<React.SetStateAction<Edge[]>>,
    fetchData: (
      endpointKey: string,
      params?: string
    ) => Promise<{
      meals: Ingredients[] | Category[] | Meal[] | Meals[];
    } | null>
  ): Promise<void> => {
    // Fetch ingredients data
    const response = await fetchData(`ingredients`);
    const ingredients = (response?.meals?.slice(0,5) || []) as Ingredients[];

    const newNodes = ingredients.map((ingredient, index) => ({
      id: `${node.data.type}-${node.data.entityId}-${ingredient?.idIngredient}`,
      type: "entityNode",
      data: {
        label: ingredient?.strIngredient,
        type: "ingredient",
        entityId: ingredient?.strIngredient,
      },
      position: {
        x: node.position.x + 350,
        y: node.position.y - 200 + index * 100,
      },
    }));

    setNodes((nds) => [...nds, ...newNodes]);
    setEdges((eds) => [...eds, ...createEdges(node.id, newNodes)]);
  };

  // Fetch tags and create tag nodes
  const handleViewTagsNode = async (
    node: Node,
    setNodes: React.Dispatch<React.SetStateAction<Node[]>>,
    setEdges: React.Dispatch<React.SetStateAction<Edge[]>>,
    fetchData: (
      endpointKey: string,
      params?: string
    ) => Promise<{
      meals: Category[] | Meal[] | Meals[] | Ingredients[];
    } | null>
  ) => {
    const response = await fetchData(`meal`, node.data.entityId);
    const mealDetails = response?.meals[0] as MealDetails;
    const items = mealDetails?.strTags ? mealDetails.strTags.split(",") : [];

    const newNodes = {
      id: `${node.data.type}-${node.data.entityId}-${0}`,
      type: "tagsNode",
      data: { tags: items, type: "tag" },
      position: {
        x: node.position.x + 350,
        y: node.position.y,
      },
    };

    setNodes((nds) => [...nds, newNodes]);
    setEdges((eds) => [...eds, ...createEdges(node.id, [newNodes])]);
  };

  // Fetch meal details and set them in the sidebar
  const handleViewDetailsNode = async (
    node: Node,
    setSelectedMeal: Dispatch<SetStateAction<Meal | undefined | null>>,
    setOpen: React.Dispatch<React.SetStateAction<boolean>>,
    fetchData: (
      endpointKey: string,
      params?: string
    ) => Promise<{
      meals: Category[] | Meal[] | Meals[] | Ingredients[];
    } | null>
  ) => {
    const response = await fetchData(`meal`, node.data.entityId);
    const mealDetails = response?.meals[0] as Meal | undefined | null;
    setSelectedMeal(mealDetails);
    setOpen(true);
  };

  const onNodeClick = useCallback(
    async (event: React.MouseEvent, node: Node) => {
      if (node.data.type === "start") {
        await handleStartNode(node, setNodes, setEdges, fetchData);
      } else if (node.data.type === "category") {
        const optionNode: Node = {
          id: `option-${node.id}`,
          type: "optionNode",
          data: {
            label: "View Meals",
            type: "viewMeals",
            entityId: node.data.entityId,
          },
          position: { x: node.position.x + 350, y: node.position.y },
        };
        setNodes((nds) => [...nds, optionNode]);
        setEdges((eds) => [
          ...eds,
          {
            id: `e-${node.id}-${optionNode.id}`,
            source: node.id,
            target: optionNode.id,
          },
        ]);
      } else if (
        node.data.type === "viewMeals" ||
        node.data.type === "ingredient"
      ) {
        await handleViewMealsNode(node, setNodes, setEdges, fetchData);
      } else if (node.data.type === "meal") {
        handleMealOptionsNode(node, setNodes, setEdges);
      } else if (node.data.type === "viewIngredients") {
        await handleViewIngredientsNode(node, setNodes, setEdges, fetchData);
      } else if (node.data.type === "viewTags") {
        await handleViewTagsNode(node, setNodes, setEdges, fetchData);
      } else if (node.data.type === "viewDetails") {
        await handleViewDetailsNode(node, setSelectedMeal, setOpen, fetchData);
      }
    },
    [fetchData, setNodes, setEdges, setSelectedMeal, setOpen]
  );

  return (
    <div style={{ width: "100vw", height: "100vh" }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        onNodeClick={onNodeClick}
        nodeTypes={nodeTypes}
        fitView
      >
        <Background />
      </ReactFlow>
      {open && (
        <MealSheet
          mealData={selectedMeal}
          open={open}
          onClose={() => setOpen(false)}
        />
      )}
    </div>
  );
}
